---
gated: true
layout: page
nav-title: Lab 2 - Stateful Enrichment
title: Lab 2 - Stateful Enrichment (Rides and Fares)
permalink: /exercises/rideEnrichment-flatmap.html
nav-parent_id: root
nav-pos: 40
---

The goal of this exercise is to join together the `TaxiRide` and `TaxiFare` records for each ride.

For each distinct `rideId`, there are exactly three events:

1. a `TaxiRide` START event
1. a `TaxiRide` END event
1. a `TaxiFare` event (whose timestamp happens to match the start time)

The result should be a `DataStream<Tuple2<TaxiRide, TaxiFare>>`, with one record one for each distinct `rideId`. Each tuple should pair the `TaxiRide` START event for some `rideId` with its matching `TaxiFare`.

### Input Data

For this exercise you will work with two data streams, one with `TaxiRide` events generated by a `TaxiRideSource` and the other with `TaxiFare` events generated by a `TaxiFareSource`. See [Using the Taxi Data Streams]({{ site.baseurl }}/setup/taxiData.html) for information on how to download the data and how to work with these stream generators.

### Expected Output

The result of this exercise is a data stream of `Tuple2<TaxiRide, TaxiFare>` records, one for each distinct `rideId`. The exercise is setup to ignore the END events, and you should join the event for the START of each ride with its corresponding fare event.

The resulting stream is printed to standard out.

### Getting Started

Rather than following these links to GitHub, you might prefer to open these classes in your IDE:

#### Tests

[com.ververica.flinktraining.exercises.datastream_java.state.RidesAndFaresTest]({{ site.tests }}/state/RidesAndFaresTest.java)

#### Exercise Classes

- Java: [com.ververica.flinktraining.exercises.datastream_java.state.RidesAndFaresExercise]({{ site.javaexercises }}/state/RidesAndFaresExercise.java)
- Scala: [com.ververica.flinktraining.exercises.datastream_scala.state.RidesAndFaresExercise]({{ site.scalaexercises }}/state/RidesAndFaresExercise.scala)


### Implementation Hints

<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingOne">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
Program Structure
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
      <div class="panel-body" markdown="span">
You can use a `RichCoFlatMap` to implement this join operation. Note that you have no control over the order of arrival of the ride and fare records for each rideId, so you'll need to be prepared to store either piece of information until the matching info arrives, at which point you can emit a `Tuple2<TaxiRide, TaxiFare>` joining the two records together.
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingTwo">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
Working with State
        </a>
      </h4>
    </div>
    <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
      <div class="panel-body" markdown="span">
You should be using Flink's managed, keyed state to buffer the data that is being held until the matching event arrives. And be sure to clear the state once it is no longer needed.
      </div>
    </div>
  </div>
</div>

### Discussion

For the purposes of this exercise it's okay to assume that the START and fare events are perfectly paired. But in a real-world application you should worry about the fact that whenever an event is missing, the other event for the same `rideId` will be held in state forever. In a [later lab]({{ site.baseurl }}/exercises/rideEnrichment-processfunction.html) we'll look at how you might handle that situation.

### Documentation

- [Working with State]({{ site.docs }}/dev/stream/state/index.html)

### Reference Solutions

Reference solutions are available at GitHub:

- Java: [RidesAndFaresSolution.java]({{site.javasolutions}}/state/RidesAndFaresSolution.java)
- Scala: [RidesAndFaresSolution.scala]({{site.scalasolutions}}/state/RidesAndFaresSolution.scala)

{% next %}
