---
gated: true
layout: page
nav-title: Lab 2 - Stateful Enrichment
title: Lab 2 - Stateful Enrichment (Rides and Fares)
permalink: /exercises/rideEnrichment-flatmap.html
nav-parent_id: root
nav-pos: 40
---

The goal of this exercise is to join together the `TaxiRide` and `TaxiFare` records for each ride.

### Input Data

For this exercise you will work with two data streams, one with `TaxiRide` events generated by a `TaxiRideSource` and the other with `TaxiFare` events generated by a `TaxiFareSource`. See [Taxi Data Streams]({{ site.baseurl }}/setup/taxiData.html) for information on how to download the data and how to work with these stream generators.

(Note that if you want to make your solution truly fault tolerant, you can use the `CheckpointedTaxiRideSource` and `CheckpointedTaxiFareSource`.)

### Expected Output

The result of this exercise is a data stream of `Tuple2<TaxiRide, TaxiFare>` records, one for each distinct `rideId`. You should ignore the END events, and only join the event for the START of each ride with its corresponding fare data.

The resulting stream should be printed to standard out.

### Getting Started

Rather than following these links to GitHub, you might prefer to open these classes in your IDE:

#### Tests

[com.ververica.flinktraining.exercises.datastream_java.state.RidesAndFaresTest]({{ site.tests }}/state/RidesAndFaresTest.java)

#### Exercise Classes

- Java: [com.ververica.flinktraining.exercises.datastream_java.state.RidesAndFaresExercise]({{ site.javaexercises }}/state/RidesAndFaresExercise.java)
- Scala: [com.ververica.flinktraining.exercises.datastream_scala.state.RidesAndFaresExercise]({{ site.scalaexercises }}/state/RidesAndFaresExercise.scala)


### Implementation Hints

<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingOne">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
Program Structure
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
      <div class="panel-body" markdown="span">
You can use a `RichCoFlatMap` to implement this join operation. Note that you have no control over the order of arrival of the ride and fare records for each rideId, so you'll need to be prepared to store either piece of information until the matching info arrives, at which point you can emit a `Tuple2<TaxiRide, TaxiFare>` joining the two records together.
      </div>
    </div>
  </div>
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingTwo">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
Working with State
        </a>
      </h4>
    </div>
    <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
      <div class="panel-body" markdown="span">
You should be using Flink's managed, keyed state to buffer the data that is being held until the matching event arrives. And be sure to clear the state once it is no longer needed.
      </div>
    </div>
  </div>
</div>

### Documentation

- [Working with State]({{ site.docs }}/dev/stream/state/index.html)

### Reference Solutions

Reference solutions are available at GitHub:

- Java: [RidesAndFaresSolution.java]({{site.javasolutions}}/state/RidesAndFaresSolution.java)
- Scala: [RidesAndFaresSolution.scala]({{site.scalasolutions}}/state/RidesAndFaresSolution.scala)

{% next %}
