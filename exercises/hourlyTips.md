---
gated: true
layout: page
title: Lab 3 - Windowed Analytics (Hourly Tips)
nav-title: Lab 3 - Exercise
permalink: /exercises/hourlyTips.html
nav-parent_id: lab3
nav-pos: 10
---

The task of the "Hourly Tips" exercise is to identify, for each hour, the driver earning the most tips. It's easiest to approach this in two steps: first use hour-long windows that compute the total tips for each driver during the hour, and then from that stream of window results, find the driver with the maximum tip total for each hour.

Please note that the program should operate in event time.

### Input Data

The input data of this exercise is a stream of `TaxiFare` events generated by the [Taxi Fare Stream Source]({{ site.baseurl }}/setup/taxiData.html).

The `TaxiFareSource` annotates the generated `DataStream<TaxiFare>` with timestamps and watermarks. Hence, there is no need to provide a custom timestamp and watermark assigner in order to correctly use event time.

### Expected Output

The result of this exercise is a data stream of `Tuple3<Long, Long, Float>` records, one for each hour. Each hourly record should contain the timestamp at the end of the hour, the driverId of the driver earning the most in tips during that hour, and the actual total of their tips.

The resulting stream should be printed to standard out.

### Getting Started

#### Tests

[com.ververica.flinktraining.exercises.datastream_java.windows.HourlyTipsTest]({{ site.tests }}/windows/HourlyTipsTest.java)

#### Exercise Classes

- Java: [com.ververica.flinktraining.exercises.datastream_java.windows.HourlyTipsExercise]({{ site.javaexercises }}/windows/HourlyTipsExercise.java)
- Scala: [com.ververica.flinktraining.exercises.datastream_scala.windows.HourlyTipsExercise]({{ site.scalaexercises }}/windows/HourlyTipsExercise.scala)

### Implementation Hints

<div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
  <div class="panel panel-default">
    <div class="panel-heading" role="tab" id="headingOne">
      <h4 class="panel-title">
        <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
Program Structure
        </a>
      </h4>
    </div>
    <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
      <div class="panel-body" markdown="span">
Note that it is possible to cascade one set of time windows after another, so long as the timeframes are compatible (the second set of windows needs to have a duration that is a multiple of the first set). So you can have a initial set of hour-long windows that is keyed by the driverId and use this to create a stream of (endOfHourTimestamp, driverId, totalTips), and then follow this with another hour-long window (this window is not keyed) that finds the record from the first window with the maximum totalTips.
      </div>
    </div>
  </div>
</div>

### Documentation

- [Windows]({{ site.docs }}/dev/stream/operators/windows.html)
- [See the section on aggregations on windows]({{ site.docs }}/dev/stream/operators/#datastream-transformations)

### Reference Solutions

Reference solutions are available at GitHub:

- Java: [HourlyTipsSolution.java]({{site.javasolutions}}/windows/HourlyTipsSolution.java)
- Scala: [HourlyTipsSolution.scala]({{site.scalasolutions}}/windows/HourlyTipsSolution.scala)

{% next %}
